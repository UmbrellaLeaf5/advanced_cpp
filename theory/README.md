**Вопросы к зачету**

**Продвинутое программирование на `С++`, 2025 г.**

1. `CMake`. Написать CMake для проекта, состоящего из `main.cpp`, `class1.h`, `class1.cpp`. Стандарт `С++` - 17.
1. `CMake`. Алгоритм сборки библиотеки без зависимостей из исходных кодов, которые содержат `CMakeLists.txt`.
1. `CMake`. Добавление сторонней прекомпилированной библиотеки к своему проекту.
1. `Git`. Отличие checkout от `switch`.
1. `Git`. Отличия `rebase`/`merge`/`cherry-pick`.
1. `Git`. Что нужно сделать, чтобы зафиксировать изменения в локальном репозитории и добавить их в удаленный репозиторий.
1. Отличия `waterfall` от `agile`.
1. Алгоритм Флойда.
1. Инварианты класса. Определение.
1. Инкапсуляция. Определение
1. Модификатор доступа в классе по умолчанию. Модификатор доступа в структуре по умолчанию.
1. Наследование в классе по умолчанию. Наследование в структуре по умолчанию.
1. Отличия `private`/`protected`/`public` (внутри определения класса и при наследовании).
1. Отличие `malloc`/`free` от `new`/`delete`.
1. Когда не применима инициализация «в круглых скобках», «после =», «фигурная».
1. Сужающие преобразованию и разные виды инициализации («в круглых скобках», «после =», «фигурная»).
1. «Наиболее неприятный анализ» в `С++` и разные виды инициализации («в круглых скобках», «фигурная»).
1. В каких случаях возникает двойная инициализация? Как избежать?
1. В каком порядке выполняется инициализация полей класса с использованием списков инициализации (в порядке расположения полей класса или в порядке, определенном в списке инициализации)? 
1. Что такое `RVO`? Пример?
1. Полиморфизм. Определение. Виды полиморфизма.
1. Примеры статического полиморфизма в `С++`.
1. Примеры динамического полиморфизма в `С++`.
1. Отличие `overloading` от `overriding`.
1. Ключевое слово `virtual`.
1. Ключевое слово `override`.
1. Абстрактный класс. Определение.
1. Использование аргументов со значениями по умолчанию в виртуальных функциях.
1. `NVI`. Пример?
1. Может ли существовать шаблон виртуального метода?
1. Можно ли перегружать виртуальные функции?
1. Как добавить в `overloading set` класса-наследника методы базового класса, являющиеся перегрузками виртуального метода?
1. Чем плох `goto`?
1. Примеры `goto` - маскирующих конструкций
1. `RAII`. Концепция.
1. Инвариант умного указателя с единственным(уникальным) владением.
1. `Drill down behavior`. Где применяется?
1. `Lvalue` и `rvalue`. Отличия.
1. `Rvalue` ссылки.
1. Что делает `std::move`?
1. Правило нуля, трех, пяти.
1. Виды умных указателей.
1. Отличие `unique_ptr` от `shared_ptr`.
1. Отличие `weak_ptr` от `shared_ptr`.
1. Способы инициализации `shared_ptr`. 
1. `ODR`.
1. `Include guards`.
1. `CV`-квалификаторы при выводе типов.
1. Манглирование имен. (Как перегрузки функций представляются компилятором).
1. Правила разрешения перегрузки для нешаблонных функций.
1. Правила разрешения перегрузки для шаблонных функций.
1. Что такое специализация шаблонного класса?
1. Что такое частичная специализация шаблонного класса?
1. Правила вывода типов для `auto`.
1. Что делает `decltype`?
1. Когда используем `auto`, а когда `decltype` для вывода типов?
1. Когда `С++` осуществляет «ленивые», а не «энергичные» вычисления?
1. SFINAE. Определение.
1. Зачем в старом `С++` (до `С++11`) для реализации `SFINAE` создавались структуры разных размеров?
1. Замена структурам разных размеров в современном `С++`.
1. `CRTP`. Определение. Зачем нужно?
1. Ограничения `CRTP`.
1. Реализация чисто виртуальных функций в `CRTP`.
1. Реализация виртуальных функций в `CRTP`.
1. Реализация методов для удаления объекта класса в `CRTP`.
1. Способы применения `CRTP`.
1. Как применяется `CRTP` для делегирования?
1. Как работает ключевое слово `required`? Когда проверятся ограничения?
1. Чем плохи `SFINAE` ограничения? Приведите пример.
1. Что такое `requires-expression`? Отличия `required-expression` от `required-clause`.
1. Виды `requires-expression`.
1. Что такое концепт? Особенности синтаксиса ограничения функций концептами.
1. Отношения между концептами.
1. Напишите концепт `Hashable`, принимающий одну шаблонную переменную `T`, который будет использоваться для проверки: существования типа `std::hash<T>`, существования `std::hash<T>::operator()` и приводимости типа возвращаемого значения `std::hash<T>::operator()` к `std::size_t`.
1. Универсальные ссылки и идеальная передача.
1. Функции `std::move` и `std::forward`.
1. Пачки параметров. Как выделить паттерн раскрытия? Что такое свертки?
1. Паттерн Декоратор.
1. Применение `CRTP` при реализации паттерна Декоратор.
1. Паттерн Адаптер.
1. Минусы паттерна декоратор при реализации потокобезопасной очереди.
1. Отличие паттерна декоратор от паттерна Адаптер.
1. Паттерн Фабрика.
1. Как реализовать фабрику для инициализации объектов с разными аргументами в их конструкторах?
1. Как реализовать полиморфное копирование с использованием фабрики?
1. Зачем использовать `CRTP` в реализации полиморфного копирования с использованием фабрики?
1. Паттерн Мост.
1. `COW`: достоинства и недостатки.
1. Паттерн Компоновщик.
1. Паттерн Строитель.
